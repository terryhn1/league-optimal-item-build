def dfs_util(item_id, item_dict, itemUsageDict, visited, candidates, selection):
    """The recursive function for DFS. Checks for visited nodes and cancels recursion if a similar item path has been encountered.
    If a similar item path has been discovered, then its best to consider that the way will lead to the same item.
    An inherent problem with this function is that one item can lead to multiple paths that can be optimal builds.
    However, this problem is fixed by gradual descent"""

    #A CANDIDATE WAS PICKED FROM CRITERIA AND ITS THE ONE WE SHOULD END WITH
    if selection != None:
        return 

    #IF IT IS STILL A SECONDARY ITEM
    if item_dict[item_id].has_key("into"):
        for item in item_dict[item_id]["into"]:
            if item not in visited:
                #THE ITEM HAS NOT BEEN VISITED AND ALL POSSIBLE ROUTES SHOULD BE EXAMINED
                visited.add(item_id)
                dfs_util(item, item_dict, visited)
            else:
                #THE ITEM HAS BEEN EXAMINED IN THE PAST. GOOD TO BREAK FROM HERE BECAUSE THAT ROUTE WILL PROB LEAD TO THE SAME
                return

    #REACHED THE END. NEEDS SOME CRITERIA.
    else:
        #Meets the basic criteria of being over 50% win Rate(good chance of winning with this item on)
        if itemUsageDict[item_id]["totalCount"] > 200 and itemUsageDict[item_id]["winRatio"] >= 0.55:
            selection = item_id

        elif itemUsageDict[item_id]["totalCount"] > 20:
            candidates.append(item_id)
        
        return

def dfs(item_id, item_dict, itemUsageDict, visited = set(), candidates = list(), selection = None):
    """Uses the DFS_Util function in order to compute for the candidate selection. If the selection is empty, then it resorts to
    using the gradual descent algorithm to figure out the best candidate out of those candidates that did not meet the strict """
    dfs_util(item_id, item_dict, itemUsageDict, visited, candidates, selection)

    if selection != None:
        return item_id

    if len(candidates) != 0:
        #SEARCHES FOR THE MAX INSTANCE WITH A GRADUAL DESCENT STEP WITH CRITERIA
        return gradual_descent(candidates, itemUsageDict)
    
    else:
        return -1

def gradual_descent(candidates, itemUsageDict, step = 0.02, win_epoch  = 0.55, occurence_epoch = 150, max_iter = 250):
    """Gradual descent attempts to solve the problem of having too strict a condition in the original selection. If no items are found at the primary search,
    gradual descent steps down with a focus of balancing the occurences met and wins. If max_iter is reached, then the item with the best win ratio is chosen.
    We can look at this as exploration into the future as this item may be used more often later."""
    while max_iter != 0:
        priority_list = list()

        for candidate in candidates:
            if itemUsageDict[candidate]["totalCount"] > occurence_epoch and itemUsageDict[candidate]["winRatio"]:
                priority_list.append(candidate)

        if len(priority_list) != 0:
            #SCORE ITEMS
            if len(priority_list) == 1:
                #base case
                return priority_list[0]
            else:
                return max(score(priority_list, sum([data["totalCount"] for item, data in itemUsageDict.items()]), itemUsageDict, 1.2), key = lambda x: x[1])[0]
        else:
            win_epoch -= win_epoch *step; occurence_epoch -= occurence_epoch * step; max_iter -= 1 


    return -1

def score(priority_list, totalItemCount, itemUsageDict, threshold):
    """Judges the candidates from the given data to see if """
    scored = list()
    for item in priority_list:
        scored.append((item, itemUsageDict[item]["winRatio"] * (itemUsageDict[item]["totalCount"]/ totalItemCount) * threshold))
    return scored


def generate_build(item_dict: dict(dict), itemUsageDict: dict(dict), championName: str, currentBuild = set()) -> list:
    """Takes in the entire item.csv and the itemUsageDict generated by SQL. ItemUsageDict is ordered by championName while the item dict is ordered by item id.
    This function attempts to fulfill all 6 slots for the build(excluding the trinket) by iterating through all items and relying on """
    i = 0 
    for itemId in itemUsageDict[championName].keys():
        #SELECT THE NEXT ITEM, ORDERED BY HIGHEST WIN RATE
        if i == 6:
            break

        newItem = dfs(itemId, item_dict, itemUsageDict[championName])
        if newItem != -1:
            currentBuild.add(newItem)
            i += 1

    return currentBuild
    